<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Qu·∫£n l√Ω H√¨nh ·∫£nh C√¢u h·ªèi - ATVSV 2025</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <!-- Prettier for JSON formatting -->
    <script src="https://unpkg.com/prettier@2.8.8/standalone.js"></script>
    <script src="https://unpkg.com/prettier@2.8.8/parser-babel.js"></script>
    <style>
        .thumbnail-container {
            width: auto;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            background-color: #f9fafb;
        }
        
        .thumbnail-image {
            height: 80px;
            width: auto;
            object-fit: cover;
        }
        
        .placeholder-thumbnail {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f3f4f6;
            color: #6b7280;
            border-radius: 4px;
        }
        
        .sidebar {
            width: 300px;
            height: 400px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background-color: white;
        }
        
        .folder-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .folder-item:hover {
            background-color: #f9fafb;
        }
        
        .folder-item.active {
            background-color: #dbeafe;
            color: #1e40af;
        }
        
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
            max-height: 900px;
            overflow-y: auto;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background-color: white;
        }
        
        .image-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        
        .image-item:hover {
            border-color: #d1d5db;
        }
        
        .image-item.selected {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        
        .image-item img {
            width: 100px;
            height: 56px;
            object-fit: cover;
            border-radius: 4px;
        }
        
        .image-item span {
            font-size: 10px;
            text-align: center;
            margin-top: 4px;
            word-break: break-all;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-content {
            width: 80%;
            height: 80%;
            background-color: white;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .batch-edit-panel {
            display: none;
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .question-text {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Header -->
    <div class="bg-white shadow-sm border-b">
        <div class="container mx-auto px-4 py-4">            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-2xl font-bold text-gray-800">
                        <i class="fas fa-images mr-2"></i>
                        Qu·∫£n l√Ω H√¨nh ·∫£nh C√¢u h·ªèi
                    </h1>                    <p class="text-sm text-gray-600 mt-1">
                        Ch·ªânh s·ª≠a h√¨nh ·∫£nh c√¢u h·ªèi, sau ƒë√≥ click "Save All" ƒë·ªÉ l∆∞u c√°c file ƒë√£ thay ƒë·ªïi. 
                        <span class="text-orange-600 font-medium">H·ªá th·ªëng t·ª± ƒë·ªông qu√©t ·∫£nh m·ªõi m·ªói 10 gi√¢y.</span>
                    </p>
                </div>                <div class="flex gap-4">
                    <button onclick="refreshImagesLibrary()" class="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded-lg flex items-center gap-2">
                        <i class="fas fa-sync-alt"></i>
                        <span>Refresh Images</span>
                    </button>
                    <button onclick="saveAllFiles()" class="save-all-btn bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg opacity-50" disabled>
                        <i class="fas fa-save mr-2"></i>Save All
                    </button>
                    <button onclick="copyAllToClipboard()" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg">
                        <i class="fas fa-copy mr-2"></i>Copy All
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Filters and Controls -->
    <div class="container mx-auto px-4 py-4">
        <div class="bg-white rounded-lg shadow-sm p-4 mb-4">
            <div class="flex items-center justify-between mb-4">
                <div class="flex items-center gap-4">
                    <select id="roundFilter" onchange="filterQuestions()" class="border rounded-lg px-3 py-2">
                        <option value="">T·∫•t c·∫£ v√≤ng</option>
                        <option value="1">V√≤ng 1</option>
                        <option value="2">V√≤ng 2</option>
                        <option value="3">V√≤ng 3</option>
                    </select>
                    <select id="categoryFilter" onchange="filterQuestions()" class="border rounded-lg px-3 py-2">
                        <option value="">T·∫•t c·∫£ danh m·ª•c</option>
                    </select>
                </div>
                <div class="flex items-center gap-4">
                    <label class="flex items-center">
                        <input type="checkbox" id="selectAll" onchange="toggleSelectAll()" class="mr-2">
                        Ch·ªçn t·∫•t c·∫£
                    </label>
                    <button onclick="toggleBatchEdit()" class="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg">
                        <i class="fas fa-edit mr-2"></i>Batch Edit
                    </button>
                </div>
            </div>

            <!-- Batch Edit Panel -->
            <div id="batchEditPanel" class="batch-edit-panel">
                <h3 class="text-lg font-semibold mb-4">Ch·ªânh s·ª≠a h√†ng lo·∫°t</h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div>
                        <label class="block text-sm font-medium mb-1">Use Image</label>
                        <select id="batchUseImage" class="w-full border rounded px-3 py-2">
                            <option value="">Kh√¥ng thay ƒë·ªïi</option>
                            <option value="Yes">Yes</option>
                            <option value="No">No</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-1">Position Image</label>
                        <select id="batchPositionImage" class="w-full border rounded px-3 py-2">
                            <option value="">Kh√¥ng thay ƒë·ªïi</option>
                            <option value="Left">Left</option>
                            <option value="Right">Right</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-1">Question Image</label>
                        <select id="batchQuestionImage" class="w-full border rounded px-3 py-2">
                            <option value="">Kh√¥ng thay ƒë·ªïi</option>
                            <option value="Yes">Yes</option>
                            <option value="No">No</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-1">BG Overlay</label>
                        <select id="batchBgOverlay" class="w-full border rounded px-3 py-2">
                            <option value="">Kh√¥ng thay ƒë·ªïi</option>
                            <option value="null">None</option>
                            <option value="gradient">Gradient</option>
                            <option value="stripes">Stripes</option>
                        </select>
                    </div>
                </div>
                <div class="mt-4 flex gap-4">
                    <button onclick="showImageGallery('batch', 'image_id')" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">
                        G√°n ·∫£nh ch√≠nh
                    </button>
                    <button onclick="showImageGallery('batch', 'bg_image')" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded">
                        G√°n ·∫£nh n·ªÅn
                    </button>
                    <button onclick="applyBatchEdit()" class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded">
                        √Åp d·ª•ng
                    </button>
                    <button onclick="toggleBatchEdit()" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">
                        H·ªßy
                    </button>
                </div>
            </div>
        </div>

        <!-- Questions Table -->
        <div class="bg-white rounded-lg shadow-sm overflow-hidden">
            <table class="w-full">                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-4 py-3 text-left"></th>
                        <th class="px-4 py-3 text-left">ID</th>
                        <th class="px-4 py-3 text-left">V√≤ng</th>
                        <th class="px-4 py-3 text-left">C√¢u s·ªë</th>
                        <th class="px-4 py-3 text-left">Danh m·ª•c</th>
                        <th class="px-4 py-3 text-left">C√¢u h·ªèi</th>
                        <th class="px-4 py-3 text-left">·∫¢nh ch√≠nh</th>
                        <th class="px-4 py-3 text-left">·∫¢nh n·ªÅn</th>
                        <th class="px-4 py-3 text-left">Thao t√°c</th>
                    </tr>
                </thead>
                <tbody id="questionsTableBody">
                    <!-- Questions will be populated here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Edit Modal -->
    <div id="editModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="flex items-center justify-between p-4 border-b">
                <h2 class="text-xl font-semibold">Ch·ªânh s·ª≠a h√¨nh ·∫£nh c√¢u h·ªèi</h2>
                <button onclick="closeEditModal()" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="flex-1 p-4 overflow-y-auto">
                <form id="editForm">
                    <input type="hidden" id="editIndex">
                    
                    <div class="grid grid-cols-2 gap-6">
                        <div>
                            <div class="mb-4">
                                <label class="block text-sm font-medium mb-2">ID c√¢u h·ªèi</label>
                                <input type="text" id="editId" readonly class="w-full border rounded-lg px-3 py-2 bg-gray-100">
                            </div>

                            <div class="mb-4">
                                <label class="block text-sm font-medium mb-2">N·ªôi dung c√¢u h·ªèi</label>
                                <textarea id="editQuestion" readonly rows="3" class="w-full border rounded-lg px-3 py-2 bg-gray-100"></textarea>
                            </div>

                            <h3 class="text-lg font-semibold mb-3">C√†i ƒë·∫∑t ·∫£nh</h3>

                            <div class="mb-4">
                                <label class="flex items-center">
                                    <input type="checkbox" id="editUseImage" class="mr-2">
                                    S·ª≠ d·ª•ng ·∫£nh
                                </label>
                            </div>

                            <div class="mb-4">
                                <label class="block text-sm font-medium mb-2">·∫¢nh ch√≠nh</label>
                                <div class="flex items-center gap-2">
                                    <div id="editImagePreview" class="thumbnail-container">
                                        <div class="placeholder-thumbnail">
                                            <i class="fas fa-image"></i>
                                        </div>
                                    </div>
                                    <button type="button" onclick="showImageGallery('edit', 'image_id')" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 rounded">
                                        Ch·ªçn ·∫£nh
                                    </button>
                                </div>
                                <input type="hidden" id="editImageId">
                            </div>

                            <div class="mb-4">
                                <label class="block text-sm font-medium mb-2">V·ªã tr√≠ ·∫£nh</label>
                                <select id="editPositionImage" class="w-full border rounded-lg px-3 py-2">
                                    <option value="Left">Left</option>
                                    <option value="Right">Right</option>
                                </select>
                            </div>

                            <div class="mb-4">
                                <label class="flex items-center">
                                    <input type="checkbox" id="editQuestionImage" class="mr-2">
                                    Question Image
                                </label>
                            </div>
                        </div>

                        <div>
                            <h3 class="text-lg font-semibold mb-3">C√†i ƒë·∫∑t n·ªÅn</h3>

                            <div class="mb-4">
                                <label class="block text-sm font-medium mb-2">·∫¢nh n·ªÅn</label>
                                <div class="flex items-center gap-2">
                                    <div id="editBgImagePreview" class="thumbnail-container">
                                        <div class="placeholder-thumbnail">
                                            <i class="fas fa-image"></i>
                                        </div>
                                    </div>
                                    <button type="button" onclick="showImageGallery('edit', 'bg_image')" class="bg-green-500 hover:bg-green-600 text-white px-3 py-2 rounded">
                                        Ch·ªçn ·∫£nh n·ªÅn
                                    </button>
                                </div>
                                <input type="hidden" id="editBgImage">
                            </div>

                            <div class="mb-4">
                                <label class="block text-sm font-medium mb-2">Overlay n·ªÅn</label>
                                <select id="editBgOverlay" class="w-full border rounded-lg px-3 py-2">
                                    <option value="null">None</option>
                                    <option value="gradient">Gradient</option>
                                    <option value="stripes">Stripes</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="p-4 border-t flex justify-end gap-4">
                <button onclick="closeEditModal()" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded-lg">
                    H·ªßy
                </button>
                <button onclick="saveQuestion()" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg">
                    L∆∞u
                </button>
            </div>
        </div>
    </div>

    <!-- Image Gallery Modal -->
    <div id="imageGalleryModal" class="modal" style="display: none;">
        <div class="modal-content">            <div class="flex items-center justify-between p-4 border-b">
                <div>
                    <h2 class="text-xl font-semibold">Ch·ªçn h√¨nh ·∫£nh</h2>
                    <p class="text-sm text-gray-500 mt-1">Gallery t·ª± ƒë·ªông c·∫≠p nh·∫≠t m·ªói 5 gi√¢y khi m·ªü</p>
                </div>
                <button onclick="closeImageGallery()" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="flex-1 flex">
                <!-- Sidebar -->                <div class="w-80 p-4 border-r">
                    <div class="mb-4">
                        <button onclick="showLocalFileUpload()" class="w-full bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg mb-4">
                            <i class="fas fa-upload mr-2"></i>Upload t·ª´ m√°y t√≠nh
                        </button>
                        <input type="file" id="localFileInput" accept=".jpg,.jpeg,.png,.svg,.webp,.gif" multiple style="display: none;" onchange="handleLocalFileUpload()">
                        <div class="text-xs text-gray-500 mb-4 p-2 bg-blue-50 rounded">
                            <i class="fas fa-info-circle mr-1"></i>
                            Th∆∞ vi·ªán ·∫£nh t·ª± ƒë·ªông refresh m·ªói 5 gi√¢y
                        </div>
                    </div>
                    
                    <h3 class="font-semibold mb-2">Th∆∞ m·ª•c</h3>
                    <div id="folderTree" class="sidebar">
                        <!-- Folder tree will be populated here -->
                    </div>
                </div>
                
                <!-- Image Grid -->
                <div class="flex-1 p-4">
                    <div id="imageGrid" class="image-grid">
                        <!-- Images will be populated here -->
                    </div>
                </div>
            </div>
            <div class="p-4 border-t flex justify-end gap-4">
                <button onclick="closeImageGallery()" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded-lg">
                    H·ªßy
                </button>
                <button onclick="selectImage()" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg">
                    Ch·ªçn
                </button>
            </div>
        </div>
    </div>

    <!-- Toast notification -->
    <div id="toast" class="fixed top-4 right-4 z-50 transform translate-x-full transition-transform duration-300">
        <div class="bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg">
            <span id="toastMessage"></span>
        </div>
    </div>

    <script>        
        // Check if Prettier is loaded
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof prettier !== 'undefined') {
                console.log('‚úÖ Prettier loaded successfully');
            } else {
                console.warn('‚ö†Ô∏è Prettier failed to load, will fallback to JSON.stringify');
            }
        });

        // Global variables
        let allQuestions = [];
        let filteredQuestions = [];
        let vong1Data = null;
        let vong2Data = null;
        let vong3Data = null;
        let selectedQuestions = new Set();
        let currentEditIndex = -1;
        let currentGalleryContext = null;
        let currentGalleryField = null;
        let selectedImagePath = null;
        let availableImages = {};
        
        // Track original data and changes
        let originalData = {
            vong1: null,
            vong2: null,
            vong3: null
        };
        let changedQuestions = new Set();        // Initialize application
        async function init() {
            try {
                await loadAllQuestions();
                populateCategoryFilter();
                displayQuestions();
                await scanImageFolders();
                updateSaveButtonState(); // Initialize save button state
                console.log('Application initialized successfully');
            } catch (error) {
                console.error('Error initializing application:', error);
                showToast('L·ªói kh·ªüi t·∫°o ·ª©ng d·ª•ng: ' + error.message, 'error');
            }
        }// Load questions from all JSON files
        async function loadAllQuestions() {
            try {
                // Load question_sets.json first to get question order
                const questionSetsResponse = await fetch('question_sets.json');
                const questionSets = await questionSetsResponse.json();
                
                // Load all question data files and store original data
                const vong1Response = await fetch('vong1.json');
                const vong2Response = await fetch('vong2.json');
                const vong3Response = await fetch('vong3.json');
                
                if (vong1Response.ok) {
                    originalData.vong1 = await vong1Response.json();
                    vong1Data = JSON.parse(JSON.stringify(originalData.vong1)); // Deep clone
                }
                
                if (vong2Response.ok) {
                    originalData.vong2 = await vong2Response.json();
                    vong2Data = JSON.parse(JSON.stringify(originalData.vong2)); // Deep clone
                }
                
                if (vong3Response.ok) {
                    originalData.vong3 = await vong3Response.json();
                    vong3Data = JSON.parse(JSON.stringify(originalData.vong3)); // Deep clone
                }

                // Create question lookup maps
                const questionMaps = {
                    1: createQuestionMap(vong1Data),
                    2: createQuestionMap(vong2Data),
                    3: createQuestionMap(vong3Data)
                };

                // Build ordered questions list based on question_sets.json
                allQuestions = [];
                buildOrderedQuestionsList(questionSets, questionMaps);

                filteredQuestions = [...allQuestions];
                console.log(`Loaded ${allQuestions.length} questions in order from question_sets.json`);
            } catch (error) {
                throw new Error('Kh√¥ng th·ªÉ t·∫£i file c√¢u h·ªèi: ' + error.message);
            }
        }// Populate category filter
        function populateCategoryFilter() {
            const categoryFilter = document.getElementById('categoryFilter');
            const categories = [...new Set(allQuestions.map(q => q.category).filter(Boolean))];
            
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });
        }

        // Filter questions based on selected criteria
        function filterQuestions() {
            const roundFilter = document.getElementById('roundFilter').value;
            const categoryFilter = document.getElementById('categoryFilter').value;

            filteredQuestions = allQuestions.filter(question => {
                const matchesRound = !roundFilter || question._round.toString() === roundFilter;
                const matchesCategory = !categoryFilter || question.category === categoryFilter;
                return matchesRound && matchesCategory;
            });

            displayQuestions();
            // Clear selections when filter changes
            selectedQuestions.clear();
            document.getElementById('selectAll').checked = false;
        }        // Display questions in table
        function displayQuestions() {
            const tbody = document.getElementById('questionsTableBody');
            tbody.innerHTML = '';

            filteredQuestions.forEach((question, index) => {
                const row = document.createElement('tr');
                row.className = 'border-b hover:bg-gray-50';
                
                const originalIndex = allQuestions.indexOf(question);
                const isSelected = selectedQuestions.has(originalIndex);
                
                // Generate question number display
                let questionNumberDisplay = 'N/A';
                if (question._round === 3 && question._domain) {
                    questionNumberDisplay = `${question._domain.toUpperCase()} - ${question._questionNumber}/${question._totalInSet}`;
                } else if (question._setNumber && question._questionNumber) {
                    questionNumberDisplay = `Set ${question._setNumber} - ${question._questionNumber}/${question._totalInSet}`;
                } else if (question._questionNumber) {
                    questionNumberDisplay = `${question._questionNumber}/${question._totalInSet || '?'}`;
                }
                
                row.innerHTML = `
                    <td class="px-4 py-3">
                        <input type="checkbox" ${isSelected ? 'checked' : ''} 
                               onchange="toggleQuestionSelection(${originalIndex})" 
                               class="question-checkbox">
                    </td>
                    <td class="px-4 py-3 font-mono text-sm">${question.id || 'N/A'}</td>
                    <td class="px-4 py-3">${question._round}</td>
                    <td class="px-4 py-3 text-sm font-medium">${questionNumberDisplay}</td>
                    <td class="px-4 py-3">${question.category || 'N/A'}</td>
                    <td class="px-4 py-3">
                        <div class="question-text" title="${question.cau_hoi || ''}">
                            ${truncateText(question.cau_hoi || '', 100)}
                        </div>
                    </td>
                    <td class="px-4 py-3">
                        ${createThumbnail(question.image_id)}
                    </td>
                    <td class="px-4 py-3">
                        ${createThumbnail(question.bg_image)}
                    </td>
                    <td class="px-4 py-3">
                        <button onclick="editQuestion(${originalIndex})" 
                                class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">
                            <i class="fas fa-edit"></i>
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
        }// Create thumbnail HTML
        function createThumbnail(imagePath) {
            if (!imagePath || imagePath === 'null') {
                return `<div class="placeholder-thumbnail"><i class="fas fa-image"></i></div>`;
            }
            
            return `
                <div class="thumbnail-container">
                    <img src="${imagePath}" 
                         class="thumbnail-image" 
                         onload="this.style.display='block'" 
                         onerror="this.style.display='none'; this.parentElement.innerHTML='<div class=&quot;placeholder-thumbnail&quot;><i class=&quot;fas fa-image&quot;></i></div>'">
                </div>
            `;
        }

        // Truncate text
        function truncateText(text, maxLength) {
            if (!text) return '';
            return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
        }

        // Toggle question selection
        function toggleQuestionSelection(index) {
            if (selectedQuestions.has(index)) {
                selectedQuestions.delete(index);
            } else {
                selectedQuestions.add(index);
            }
            
            // Update select all checkbox
            const totalVisible = filteredQuestions.length;
            const selectedVisible = filteredQuestions.filter(q => selectedQuestions.has(allQuestions.indexOf(q))).length;
            document.getElementById('selectAll').checked = selectedVisible === totalVisible && totalVisible > 0;
        }

        // Toggle select all
        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAll').checked;
            
            if (selectAll) {
                filteredQuestions.forEach(question => {
                    selectedQuestions.add(allQuestions.indexOf(question));
                });
            } else {
                filteredQuestions.forEach(question => {
                    selectedQuestions.delete(allQuestions.indexOf(question));
                });
            }
            
            displayQuestions();
        }

        // Toggle batch edit panel
        function toggleBatchEdit() {
            const panel = document.getElementById('batchEditPanel');
            const isVisible = panel.style.display !== 'none';
            panel.style.display = isVisible ? 'none' : 'block';
            
            if (isVisible) {
                // Reset batch edit form
                document.getElementById('batchUseImage').value = '';
                document.getElementById('batchPositionImage').value = '';
                document.getElementById('batchQuestionImage').value = '';
                document.getElementById('batchBgOverlay').value = '';
            }
        }        // Apply batch edit
        function applyBatchEdit() {
            if (selectedQuestions.size === 0) {
                showToast('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt c√¢u h·ªèi', 'error');
                return;
            }

            const useImage = document.getElementById('batchUseImage').value;
            const positionImage = document.getElementById('batchPositionImage').value;
            const questionImage = document.getElementById('batchQuestionImage').value;
            const bgOverlay = document.getElementById('batchBgOverlay').value;

            let changedQuestionsCount = 0;
            selectedQuestions.forEach(index => {
                const question = allQuestions[index];
                
                // Store original values for comparison
                const originalValues = {
                    use_image: question.use_image,
                    position_image: question.position_image,
                    question_image: question.question_image,
                    bg_image_overlay: question.bg_image_overlay
                };
                
                // Apply changes
                if (useImage) {
                    question.use_image = useImage;
                }
                if (positionImage) {
                    question.position_image = positionImage;
                }
                if (questionImage) {
                    question.question_image = questionImage;
                }
                if (bgOverlay) {
                    question.bg_image_overlay = bgOverlay === 'null' ? null : bgOverlay;
                }
                
                // Check if anything actually changed
                let hasChanges = false;
                for (const key in originalValues) {
                    if (originalValues[key] !== question[key]) {
                        hasChanges = true;
                        break;
                    }
                }
                
                if (hasChanges) {
                    trackQuestionChange(question.id);
                    changedQuestionsCount++;
                }
            });

            displayQuestions();
            toggleBatchEdit();
            showToast(`ƒê√£ c·∫≠p nh·∫≠t ${changedQuestionsCount} c√¢u h·ªèi`);
        }

        // Edit single question
        function editQuestion(index) {
            currentEditIndex = index;
            const question = allQuestions[index];
            
            // Populate form
            document.getElementById('editIndex').value = index;
            document.getElementById('editId').value = question.id || '';
            document.getElementById('editQuestion').value = question.cau_hoi || '';
            document.getElementById('editUseImage').checked = question.use_image === 'Yes';
            document.getElementById('editImageId').value = question.image_id || '';
            document.getElementById('editPositionImage').value = question.position_image || 'Right';
            document.getElementById('editQuestionImage').checked = question.question_image === 'Yes';
            document.getElementById('editBgImage').value = question.bg_image || '';
            document.getElementById('editBgOverlay').value = question.bg_image_overlay === null ? 'null' : (question.bg_image_overlay || 'null');
            
            // Update image previews
            updateImagePreview('editImagePreview', question.image_id);
            updateImagePreview('editBgImagePreview', question.bg_image);
            
            // Show modal
            document.getElementById('editModal').style.display = 'flex';
        }        // Update image preview
        function updateImagePreview(containerId, imagePath) {
            const container = document.getElementById(containerId);
            if (!imagePath || imagePath === 'null') {
                container.innerHTML = '<div class="placeholder-thumbnail"><i class="fas fa-image"></i></div>';
            } else {
                container.innerHTML = `
                    <img src="${imagePath}" 
                         class="thumbnail-image" 
                         onerror="this.parentElement.innerHTML='<div class=&quot;placeholder-thumbnail&quot;><i class=&quot;fas fa-image&quot;></i></div>'">
                `;
            }
        }        // Save question changes
        function saveQuestion() {
            const index = parseInt(document.getElementById('editIndex').value);
            const question = allQuestions[index];
            
            // Store original values for comparison
            const originalValues = {
                use_image: question.use_image,
                image_id: question.image_id,
                position_image: question.position_image,
                question_image: question.question_image,
                bg_image: question.bg_image,
                bg_image_overlay: question.bg_image_overlay
            };
            
            // Update question properties
            question.use_image = document.getElementById('editUseImage').checked ? 'Yes' : 'No';
            question.image_id = document.getElementById('editImageId').value || null;
            question.position_image = document.getElementById('editPositionImage').value;
            question.question_image = document.getElementById('editQuestionImage').checked ? 'Yes' : 'No';
            question.bg_image = document.getElementById('editBgImage').value || null;
            const bgOverlayValue = document.getElementById('editBgOverlay').value;
            question.bg_image_overlay = bgOverlayValue === 'null' ? null : bgOverlayValue;
            
            // Check if anything actually changed
            let hasChanges = false;
            for (const key in originalValues) {
                if (originalValues[key] !== question[key]) {
                    hasChanges = true;
                    break;
                }
            }
            
            if (hasChanges) {
                trackQuestionChange(question.id);
                showToast('ƒê√£ l∆∞u thay ƒë·ªïi c√¢u h·ªèi');
            } else {
                showToast('Kh√¥ng c√≥ thay ƒë·ªïi n√†o');
            }
            
            closeEditModal();
            displayQuestions();
        }

        // Close edit modal
        function closeEditModal() {
            document.getElementById('editModal').style.display = 'none';
            currentEditIndex = -1;
        }        // Scan image folders
        async function scanImageFolders() {
            showToast('ƒêang qu√©t th∆∞ m·ª•c ·∫£nh...', 'info');
            
            // Try smart detection first (combines index + new detection)
            await smartImageDetection();
        }

        // Enhanced image detection method
        async function enhancedImageDetection() {
            const commonExtensions = ['jpg', 'jpeg', 'png', 'svg', 'webp', 'gif', 'bmp'];
            const imageFolders = [
                'images',
                'images/bg', 
                'images/cauhoi',
                'images/illustrative',
                'images/index_images',
                'images/image_upload'
            ];
            
            const newAvailableImages = {};
            let totalFound = 0;
            
            for (const folder of imageFolders) {
                console.log(`üîç Scanning folder: ${folder}`);
                const detectedImages = [];
                  // Comprehensive test patterns for different image types
                const testPatterns = [
                    // Background images - expanded range
                    ...Array.from({length: 50}, (_, i) => `bg${i + 1}`),
                    ...Array.from({length: 20}, (_, i) => `bg${i + 1}.1`),
                    'bg', 'background', 'bgd',
                    
                    // Question images
                    ...Array.from({length: 50}, (_, i) => `image${i + 1}`),
                    ...Array.from({length: 50}, (_, i) => `v1_image${i + 1}`),
                    ...Array.from({length: 50}, (_, i) => `v2_image${i + 1}`),
                    ...Array.from({length: 50}, (_, i) => `v3_image${i + 1}`),
                    
                    // KTM (Ki·∫øn th·ª©c m√¥i tr∆∞·ªùng) images
                    ...Array.from({length: 50}, (_, i) => `ktm_image_${i + 1}`),
                    ...Array.from({length: 50}, (_, i) => `V2_KTM_HA_${i + 1}`),
                    
                    // BV (B·∫£o v·ªá) images
                    ...Array.from({length: 50}, (_, i) => `V2_BV_HA_${i + 1}`),
                    
                    // BXV (B·∫£o v·ªá x√£ vi√™n) images  
                    ...Array.from({length: 50}, (_, i) => `V2_BXV_HA_${i + 1}`),
                    
                    // Vong 3 images
                    ...Array.from({length: 30}, (_, i) => `v3_c${i + 1}`),
                    'v3_yte', 'v3_yte2',
                    
                    // Illustrative images
                    'illustrative_cspl_tn_1', 'illustrative_cspl_tn_2', 'illustrative_cspl_tn_3',
                    'illustrative_cspl_tn_5', 'illustrative_yt_sc_tn_3', 'illustrative_yt_th_1',
                    
                    // SVG files
                    'svg (1)', 'svg (2)', 'svg (3)', 'svg',
                    
                    // Index images (numbered)
                    ...Array.from({length: 100}, (_, i) => `${i + 1}`),
                    
                    // Common image names
                    'logo', 'icon', 'banner', 'header', 'footer', 'warning', 'check', 'arrow',
                    'safety1', 'safety2', 'diagram', 'chart', 'graph'
                ];
                
                // Test each pattern with each extension
                const batchSize = 10; // Process in batches to avoid blocking UI
                for (let i = 0; i < testPatterns.length; i += batchSize) {
                    const batch = testPatterns.slice(i, i + batchSize);
                    
                    await Promise.all(batch.map(async (pattern) => {
                        for (const ext of commonExtensions) {
                            const testPath = `${folder}/${pattern}.${ext}`;
                            if (await imageExists(testPath)) {
                                const fileName = `${pattern}.${ext}`;
                                if (!detectedImages.includes(fileName)) {
                                    detectedImages.push(fileName);
                                }
                            }
                        }
                    }));
                    
                    // Small delay to prevent blocking
                    if (i % (batchSize * 3) === 0) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                // Sort and store results
                newAvailableImages[folder] = detectedImages.sort((a, b) => {
                    // Custom sort: numbers first, then alphabetical
                    const aNum = parseInt(a.match(/^\d+/)?.[0]);
                    const bNum = parseInt(b.match(/^\d+/)?.[0]);
                    
                    if (aNum && bNum) return aNum - bNum;
                    if (aNum && !bNum) return -1;
                    if (!aNum && bNum) return 1;
                    return a.localeCompare(b);
                });
                
                totalFound += detectedImages.length;
                console.log(`üìÅ ${folder}: Found ${detectedImages.length} images`);
            }
            
            availableImages = newAvailableImages;
            console.log(`‚úÖ Total images detected: ${totalFound}`);
            showToast(`ƒê√£ qu√©t xong: t√¨m th·∫•y ${totalFound} ·∫£nh trong ${imageFolders.length} th∆∞ m·ª•c`);
        }        // Check if image exists with improved timeout and caching
        function imageExists(path) {
            return new Promise((resolve) => {
                const img = new Image();
                
                // Set up timeout
                const timeout = setTimeout(() => {
                    img.onload = null;
                    img.onerror = null;
                    resolve(false);
                }, 800); // Reduced timeout for faster scanning
                
                img.onload = () => {
                    clearTimeout(timeout);
                    resolve(true);
                };
                
                img.onerror = () => {
                    clearTimeout(timeout);
                    resolve(false);
                };
                
                // Add cache busting for more accurate detection
                img.src = path + '?t=' + Date.now();
            });
        }        // Main refresh function for images library
        async function refreshImagesLibrary() {
            const refreshBtn = document.querySelector('button[onclick="refreshImagesLibrary()"]');
            const originalContent = refreshBtn.innerHTML;
            
            // Show loading state
            refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>ƒêang qu√©t...</span>';
            refreshBtn.disabled = true;
            
            try {
                await scanImageFolders();
                
                // Show debug info in console
                showScanDebugInfo();
                
                // Update gallery if it's open
                if (document.getElementById('imageGalleryModal').style.display === 'flex') {
                    populateFolderTree();
                    // Refresh current folder view
                    const activeFolder = document.querySelector('.folder-item.active');
                    if (activeFolder && activeFolder.dataset.folder) {
                        showImagesInFolder(activeFolder.dataset.folder);
                    }
                }
                
                const total = Object.values(availableImages).flat().length;
                showToast(`‚úÖ ƒê√£ refresh th√†nh c√¥ng: ${total} ·∫£nh`);
                
            } catch (error) {
                console.error('Error refreshing images:', error);
                showToast('‚ùå L·ªói khi refresh ·∫£nh: ' + error.message, 'error');
                
            } finally {
                // Restore button state
                refreshBtn.innerHTML = originalContent;
                refreshBtn.disabled = false;
            }
        }// Show image gallery
        function showImageGallery(context, field) {
            currentGalleryContext = context;
            currentGalleryField = field;
            selectedImagePath = null;
            
            populateFolderTree();
            showImagesInFolder('images');
            
            // Start auto-refresh
            startGalleryAutoRefresh();
            
            document.getElementById('imageGalleryModal').style.display = 'flex';
        }

        // Populate folder tree
        function populateFolderTree() {
            const folderTree = document.getElementById('folderTree');
            folderTree.innerHTML = '';
            
            Object.keys(availableImages).forEach(folder => {
                const folderItem = document.createElement('div');
                folderItem.className = 'folder-item';
                folderItem.innerHTML = `
                    <i class="fas fa-folder mr-2"></i>
                    ${folder.split('/').pop()}
                `;
                folderItem.dataset.folder = folder; // Store folder path in data attribute
                folderItem.onclick = () => showImagesInFolder(folder);
                folderTree.appendChild(folderItem);
            });
        }

        // Show images in folder
        function showImagesInFolder(folder) {
            // Update active folder
            document.querySelectorAll('.folder-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.folder === folder) {
                    item.classList.add('active');
                }
            });
            
            const imageGrid = document.getElementById('imageGrid');
            imageGrid.innerHTML = '';
            
            const images = availableImages[folder] || [];
            images.forEach(imageName => {
                const imagePath = `${folder}/${imageName}`;
                const imageItem = document.createElement('div');
                imageItem.className = 'image-item';
                imageItem.onclick = () => selectImageFromGrid(imagePath, imageItem);
                
                imageItem.innerHTML = `
                    <img src="${imagePath}" 
                         onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjU2IiB2aWV3Qm94PSIwIDAgMTAwIDU2IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxMDAiIGhlaWdodD0iNTYiIGZpbGw9IiNmM2Y0ZjYiLz48dGV4dCB4PSI1MCIgeT0iMzAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiM2YjcyODAiIGZvbnQtc2l6ZT0iMTIiPk5vIEltYWdlPC90ZXh0Pjwvc3ZnPg=='"
                         alt="${imageName}">
                    <span>${imageName}</span>
                `;
                
                imageGrid.appendChild(imageItem);
            });
        }

        // Select image from grid
        function selectImageFromGrid(imagePath, element) {
            // Remove previous selection
            document.querySelectorAll('.image-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Add selection to clicked item
            element.classList.add('selected');
            selectedImagePath = imagePath;
        }

        // Select image (confirm selection)
        function selectImage() {
            if (!selectedImagePath) {
                showToast('Vui l√≤ng ch·ªçn m·ªôt h√¨nh ·∫£nh', 'error');
                return;
            }
            
            if (currentGalleryContext === 'edit') {
                // Update edit form
                if (currentGalleryField === 'image_id') {
                    document.getElementById('editImageId').value = selectedImagePath;
                    updateImagePreview('editImagePreview', selectedImagePath);
                } else if (currentGalleryField === 'bg_image') {
                    document.getElementById('editBgImage').value = selectedImagePath;
                    updateImagePreview('editBgImagePreview', selectedImagePath);
                }
            } else if (currentGalleryContext === 'batch') {
                // Apply to selected questions
                if (selectedQuestions.size === 0) {
                    showToast('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt c√¢u h·ªèi', 'error');
                    return;
                }
                
                selectedQuestions.forEach(index => {
                    const question = allQuestions[index];
                    question[currentGalleryField] = selectedImagePath;
                });
                
                displayQuestions();
                showToast(`ƒê√£ g√°n ·∫£nh cho ${selectedQuestions.size} c√¢u h·ªèi`);
            }
            
            closeImageGallery();
        }

        // Close image gallery
        function closeImageGallery() {
            document.getElementById('imageGalleryModal').style.display = 'none';
            currentGalleryContext = null;
            currentGalleryField = null;
            selectedImagePath = null;
        }

        // Show local file upload
        function showLocalFileUpload() {
            document.getElementById('localFileInput').click();
        }

        // Handle local file upload
        async function handleLocalFileUpload() {
            const fileInput = document.getElementById('localFileInput');
            const files = Array.from(fileInput.files);
            
            if (files.length === 0) return;
            
            // Create image_upload folder if not exists
            if (!availableImages['images/image_upload']) {
                availableImages['images/image_upload'] = [];
            }
            
            for (const file of files) {
                const timestamp = Date.now();
                const newFileName = `upload_${timestamp}_${file.name}`;
                
                // In a real implementation, you would upload the file to server
                // For now, we'll just simulate adding it to the list
                availableImages['images/image_upload'].push(newFileName);
                
                // Create object URL for immediate use
                const objectURL = URL.createObjectURL(file);
                // Store the object URL temporarily (in real app, this would be the server path)
                availableImages[`images/image_upload/${newFileName}`] = objectURL;
            }
            
            // Refresh folder tree and show uploaded images
            populateFolderTree();
            showImagesInFolder('images/image_upload');
            
            showToast(`ƒê√£ upload ${files.length} file`);
        }        // Save all files
        async function saveAllFiles() {
            if (changedQuestions.size === 0) {
                showToast('Kh√¥ng c√≥ thay ƒë·ªïi n√†o ƒë·ªÉ l∆∞u', 'error');
                return;
            }
            
            try {
                const changedFiles = getChangedFilesData();
                const fileCount = Object.keys(changedFiles).length;
                
                if (fileCount === 0) {
                    showToast('Kh√¥ng c√≥ file n√†o c·∫ßn l∆∞u', 'error');
                    return;
                }
                
                // Check if File System Access API is supported
                if ('showSaveFilePicker' in window) {
                    for (const [filename, data] of Object.entries(changedFiles)) {
                        await saveFileWithAPI(filename, data);
                    }
                } else {
                    // Fallback to download
                    for (const [filename, data] of Object.entries(changedFiles)) {
                        downloadFile(data, filename);
                        await new Promise(resolve => setTimeout(resolve, 100)); // Small delay between downloads
                    }
                }
                
                showToast(`ƒê√£ l∆∞u ${fileCount} file ƒë√£ thay ƒë·ªïi`);
                
                // Clear changed tracking after successful save
                changedQuestions.clear();
                updateSaveButtonState();
                
            } catch (error) {
                console.error('Error saving files:', error);
                showToast('L·ªói khi l∆∞u file: ' + error.message, 'error');
            }
        }        // Save with File System Access API
        async function saveWithFileSystemAPI(data, suggestedName) {
            try {
                const fileHandle = await window.showSaveFilePicker({
                    suggestedName: suggestedName,
                    types: [{
                        description: 'JSON files',
                        accept: { 'application/json': ['.json'] }
                    }]
                });
                  const writable = await fileHandle.createWritable();
                const formattedContent = formatJSONWithPrettier(data);
                await writable.write(formattedContent);
                await writable.close();
                
                return true;
            } catch (error) {
                if (error.name !== 'AbortError') {
                    throw error;
                }
                return false;
            }
        }

        // Format JSON v·ªõi Prettier v√† custom handling cho arrays ng·∫Øn
        function formatJSONWithPrettier(data) {
            try {
                // Prettier config t∆∞∆°ng t·ª± VS Code
                const prettierConfig = {
                    parser: 'json',
                    tabWidth: 2,
                    useTabs: false,
                    printWidth: 80,
                    trailingComma: 'none',
                    bracketSpacing: true,
                    semi: true,
                    singleQuote: false
                };

                // Format v·ªõi Prettier
                const jsonString = JSON.stringify(data);
                let formatted = prettier.format(jsonString, prettierConfig);
                
                // Custom post-processing ƒë·ªÉ compact short arrays nh∆∞ dap_an_dung
                formatted = formatted.replace(
                    /"dap_an_dung":\s*\[\s*\n(\s*"[a-h]",?\s*\n)+\s*\]/g,
                    (match) => {
                        const values = match.match(/"[a-h]"/g);
                        return `"dap_an_dung": [${values.join(', ')}]`;
                    }
                );
                
                // Compact c√°c arrays ng·∫Øn kh√°c (‚â§ 5 elements, m·ªói element ‚â§ 10 chars)
                formatted = formatted.replace(
                    /:\s*\[\s*\n(\s*"[^"]{1,10}",?\s*\n){1,5}\s*\]/g,
                    (match) => {
                        const values = match.match(/"[^"]*"/g);
                        if (values && values.length <= 5) {
                            const key = match.split(':')[0].trim();
                            return `${key}: [${values.join(', ')}]`;
                        }
                        return match;
                    }
                );
                
                return formatted;
            } catch (error) {
                console.warn('Prettier format failed, fallback to JSON.stringify:', error);
                return JSON.stringify(data, null, 2);
            }
        }        // Helper function to download file
        function downloadFile(data, filename) {
            const formattedContent = formatJSONWithPrettier(data);
            const blob = new Blob([formattedContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Save round data (kept for backward compatibility)
        function saveRound(round) {
            try {
                let dataToSave;
                let filename;
                
                if (round === 1) {
                    dataToSave = reconstructVong1Data();
                    filename = 'vong1.json';
                } else if (round === 2) {
                    dataToSave = reconstructVong2Data();
                    filename = 'vong2.json';
                } else if (round === 3) {
                    dataToSave = reconstructVong3Data();
                    filename = 'vong3.json';
                }
                
                downloadFile(dataToSave, filename);
                showToast(`ƒê√£ l∆∞u ${filename}`);
            } catch (error) {
                console.error('Error saving round:', error);
                showToast('L·ªói khi l∆∞u file: ' + error.message, 'error');
            }
        }

        // Reconstruct vong1 data
        function reconstructVong1Data() {
            const result = JSON.parse(JSON.stringify(vong1Data));
            
            // Update questions in their original positions
            const vong1Questions = allQuestions.filter(q => q._round === 1);
            
            function updateNestedStructure(obj, path = []) {
                if (Array.isArray(obj)) {
                    obj.forEach((item, index) => {
                        const question = vong1Questions.find(q => 
                            JSON.stringify(q._path) === JSON.stringify(path) && 
                            q._originalIndex === index
                        );
                        if (question) {
                            // Remove metadata before saving
                            const cleanQuestion = { ...question };
                            delete cleanQuestion._round;
                            delete cleanQuestion._originalIndex;
                            delete cleanQuestion._path;
                            Object.assign(item, cleanQuestion);
                        }
                    });
                } else if (obj && typeof obj === 'object') {
                    for (const [key, value] of Object.entries(obj)) {
                        updateNestedStructure(value, [...path, key]);
                    }
                }
            }
            
            updateNestedStructure(result);
            return result;
        }

        // Reconstruct vong2 data
        function reconstructVong2Data() {
            const result = JSON.parse(JSON.stringify(vong2Data));
            
            const vong2Questions = allQuestions.filter(q => q._round === 2);
            
            function updateNestedStructure(obj, path = []) {
                if (Array.isArray(obj)) {
                    obj.forEach((item, index) => {
                        const question = vong2Questions.find(q => 
                            JSON.stringify(q._path) === JSON.stringify(path) && 
                            q._originalIndex === index
                        );
                        if (question) {
                            const cleanQuestion = { ...question };
                            delete cleanQuestion._round;
                            delete cleanQuestion._originalIndex;
                            delete cleanQuestion._path;
                            Object.assign(item, cleanQuestion);
                        }
                    });
                } else if (obj && typeof obj === 'object') {
                    for (const [key, value] of Object.entries(obj)) {
                        updateNestedStructure(value, [...path, key]);
                    }
                }
            }
            
            updateNestedStructure(result);
            return result;
        }

        // Reconstruct vong3 data
        function reconstructVong3Data() {
            const result = JSON.parse(JSON.stringify(vong3Data));
            
            const vong3Questions = allQuestions.filter(q => q._round === 3);
            
            function updateNestedStructure(obj, path = []) {
                if (Array.isArray(obj)) {
                    obj.forEach((item, index) => {
                        const question = vong3Questions.find(q => 
                            JSON.stringify(q._path) === JSON.stringify(path) && 
                            q._originalIndex === index
                        );
                        if (question) {
                            const cleanQuestion = { ...question };
                            delete cleanQuestion._round;
                            delete cleanQuestion._originalIndex;
                            delete cleanQuestion._path;
                            Object.assign(item, cleanQuestion);
                        }
                    });
                } else if (obj && typeof obj === 'object') {
                    for (const [key, value] of Object.entries(obj)) {
                        updateNestedStructure(value, [...path, key]);
                    }
                }
            }
            
            updateNestedStructure(result);
            return result;
        }

        // Create question map from JSON data
        function createQuestionMap(data) {
            const questionMap = new Map();
            
            function findQuestions(obj, path = []) {
                if (Array.isArray(obj)) {
                    obj.forEach((question, index) => {
                        if (question && typeof question === 'object' && question.id) {
                            question._originalIndex = index;
                            question._path = [...path];
                            questionMap.set(question.id, question);
                        }
                    });
                } else if (obj && typeof obj === 'object') {
                    for (const [key, value] of Object.entries(obj)) {
                        findQuestions(value, [...path, key]);
                    }
                }
            }
            
            findQuestions(data);
            return questionMap;
        }

        // Build ordered questions list based on question_sets.json
        function buildOrderedQuestionsList(questionSets, questionMaps) {
            // Process Vong 1
            if (questionSets.vong1) {
                Object.entries(questionSets.vong1).forEach(([setNumber, questionIds]) => {
                    questionIds.forEach((questionId, index) => {
                        const question = questionMaps[1].get(questionId);
                        if (question) {
                            const orderedQuestion = { ...question };
                            orderedQuestion._round = 1;
                            orderedQuestion._setNumber = setNumber;
                            orderedQuestion._questionNumber = index + 1;
                            orderedQuestion._totalInSet = questionIds.length;
                            allQuestions.push(orderedQuestion);
                        } else {
                            console.warn(`Question ${questionId} not found in vong1 data`);
                        }
                    });
                });
            }

            // Process Vong 2
            if (questionSets.vong2) {
                Object.entries(questionSets.vong2).forEach(([setNumber, questionIds]) => {
                    questionIds.forEach((questionId, index) => {
                        const question = questionMaps[2].get(questionId);
                        if (question) {
                            const orderedQuestion = { ...question };
                            orderedQuestion._round = 2;
                            orderedQuestion._setNumber = setNumber;
                            orderedQuestion._questionNumber = index + 1;
                            orderedQuestion._totalInSet = questionIds.length;
                            allQuestions.push(orderedQuestion);
                        } else {
                            console.warn(`Question ${questionId} not found in vong2 data`);
                        }
                    });
                });
            }

            // Process Vong 3
            if (questionSets.vong3) {
                Object.entries(questionSets.vong3).forEach(([domain, questionIds]) => {
                    questionIds.forEach((questionId, index) => {
                        const question = questionMaps[3].get(questionId);
                        if (question) {
                            const orderedQuestion = { ...question };
                            orderedQuestion._round = 3;
                            orderedQuestion._domain = domain;
                            orderedQuestion._questionNumber = index + 1;
                            orderedQuestion._totalInSet = questionIds.length;
                            allQuestions.push(orderedQuestion);
                        } else {
                            console.warn(`Question ${questionId} not found in vong3 data`);
                        }
                    });
                });
            }
        }

        // Debug function to show scan results
        function showScanDebugInfo() {
            console.log('üìä Current image scan results:');
            console.log('='.repeat(50));
            
            Object.keys(availableImages).forEach(folder => {
                const images = availableImages[folder] || [];
                console.log(`üìÅ ${folder}: ${images.length} images`);
                
                if (images.length > 0) {
                    // Show first few and last few
                    const preview = images.length > 10 
                        ? [...images.slice(0, 5), '...', ...images.slice(-5)]
                        : images;
                    console.log(`   ‚îî‚îÄ‚îÄ ${preview.join(', ')}`);
                }
            });
            
            const total = Object.values(availableImages).flat().length;
            console.log('='.repeat(50));
            console.log(`üìä Total: ${total} images across ${Object.keys(availableImages).length} folders`);
            
            return { 
                folders: Object.keys(availableImages).length,
                total: total,
                details: availableImages 
            };
        }

        // Add to window for manual debugging
        window.debugImageScan = showScanDebugInfo;

        // Toast notification
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            
            toastMessage.textContent = message;
            
            if (type === 'error') {
                toast.firstElementChild.className = 'bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg';
            } else {
                toast.firstElementChild.className = 'bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg';
            }
            
            toast.style.transform = 'translateX(0)';
            
            setTimeout(() => {
                toast.style.transform = 'translateX(100%)';
            }, 3000);
        }        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            init();
            // Start global auto-refresh on page load
            startGlobalAutoRefresh();
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            stopGlobalAutoRefresh();
        });

        // Enhanced refresh images list function
        async function enhancedRefreshImagesList() {
            console.log('üîÑ Enhanced auto-refreshing images list...');
            
            const commonExtensions = ['jpg', 'jpeg', 'png', 'svg', 'webp', 'gif'];
            const imageFolders = Object.keys(availableImages);
            
            const newAvailableImages = {};
            let hasChanges = false;
            
            for (const folder of imageFolders) {
                const oldImages = availableImages[folder] || [];
                const newImages = [];
                  // Only test a subset of patterns for auto-refresh (performance)
                const quickTestPatterns = [
                    // Most common patterns - expanded for better coverage
                    ...Array.from({length: 30}, (_, i) => `bg${i + 1}`), // Extended to bg30
                    ...Array.from({length: 15}, (_, i) => `image${i + 1}`),
                    ...Array.from({length: 15}, (_, i) => `v3_c${i + 1}`),
                    ...Array.from({length: 25}, (_, i) => `${i + 1}`), // Extended numbered files
                    'v3_yte', 'v3_yte2', 'logo', 'icon', 'bg', 'bg2.1'
                ];
                
                // Test existing images first (faster)
                for (const existingImage of oldImages) {
                    const testPath = `${folder}/${existingImage}`;
                    if (await imageExists(testPath)) {
                        newImages.push(existingImage);
                    }
                }
                
                // Then test for new images with quick patterns
                for (const pattern of quickTestPatterns) {
                    for (const ext of commonExtensions) {
                        const fileName = `${pattern}.${ext}`;
                        const testPath = `${folder}/${fileName}`;
                        
                        if (!newImages.includes(fileName) && await imageExists(testPath)) {
                            newImages.push(fileName);
                        }
                    }
                }
                
                // Check for uploaded images in upload folder
                if (folder === 'images/image_upload') {
                    // Keep uploaded images from previous state
                    newImages.push(...(availableImages[folder] || []));
                }
                
                // Sort images
                newImages.sort((a, b) => {
                    const aNum = parseInt(a.match(/^\d+/)?.[0]);
                    const bNum = parseInt(b.match(/^\d+/)?.[0]);
                    
                    if (aNum && bNum) return aNum - bNum;
                    if (aNum && !bNum) return -1;
                    if (!aNum && bNum) return 1;
                    return a.localeCompare(b);
                });
                
                newAvailableImages[folder] = newImages;
                
                // Check if this folder has changes
                if (oldImages.length !== newImages.length || 
                    !oldImages.every(img => newImages.includes(img))) {
                    hasChanges = true;
                    console.log(`üìÅ ${folder}: ${oldImages.length} ‚Üí ${newImages.length} images`);
                }
            }
            
            if (hasChanges) {
                const oldTotal = Object.values(availableImages).flat().length;
                availableImages = newAvailableImages;
                const newTotal = Object.values(availableImages).flat().length;
                
                console.log(`‚úÖ Images updated: ${oldTotal} ‚Üí ${newTotal}`);
                
                // Update gallery if open
                if (document.getElementById('imageGalleryModal').style.display === 'flex') {
                    populateFolderTree();
                    const activeFolder = document.querySelector('.folder-item.active');
                    if (activeFolder && activeFolder.dataset.folder) {
                        showImagesInFolder(activeFolder.dataset.folder);
                    }
                }
                
                // Show subtle notification for auto-updates
                showToast(`üîÑ C·∫≠p nh·∫≠t: ${newTotal} ·∫£nh`, 'info');
                return true;
            }
            
            return false; // No changes
        }
        
        // Smart scanning that combines index file + new file detection
        async function smartImageDetection() {
            console.log('üß† Starting smart image detection...');
            
            // First, try to load from index file
            let baseImages = {};
            try {
                const response = await fetch('images_index.json?t=' + Date.now());
                if (response.ok) {
                    baseImages = await response.json();
                    console.log('üìã Loaded base images from index file');
                }
            } catch (error) {
                console.log('‚ö†Ô∏è No index file found, starting fresh scan');
            }
            
            const commonExtensions = ['jpg', 'jpeg', 'png', 'svg', 'webp', 'gif', 'bmp'];
            const imageFolders = [
                'images',
                'images/bg', 
                'images/cauhoi',
                'images/illustrative',
                'images/index_images',
                'images/image_upload'
            ];
            
            const newAvailableImages = {};
            let totalFound = 0;
            
            for (const folder of imageFolders) {
                console.log(`üîç Smart scanning folder: ${folder}`);
                const detectedImages = [];
                const baseImagesInFolder = baseImages[folder] || [];
                
                // First, verify existing images from index
                for (const existingImage of baseImagesInFolder) {
                    const testPath = `${folder}/${existingImage}`;
                    if (await imageExists(testPath)) {
                        detectedImages.push(existingImage);
                    }
                }
                
                // Then look for new images with extended patterns
                const extendedPatterns = [
                    // Extended background images (up to 50)
                    ...Array.from({length: 50}, (_, i) => `bg${i + 1}`),
                    'bg', 'bg2.1', 'background',
                    
                    // Extended question images
                    ...Array.from({length: 30}, (_, i) => `image${i + 1}`),
                    ...Array.from({length: 30}, (_, i) => `v3_c${i + 1}`),
                    
                    // Extended numbered files
                    ...Array.from({length: 50}, (_, i) => `${i + 1}`),
                    
                    // Common names
                    'v3_yte', 'v3_yte2', 'logo', 'icon', 'ktm_image_4',
                    'V2_BV_HA_4', 'V2_BV_HA_9', 'V2_BXV_HA_15', 'V2_BXV_HA_22',
                    'V2_KTM_HA_10', 'V2_KTM_HA_4'
                ];
                
                // Test for new images
                for (const pattern of extendedPatterns) {
                    for (const ext of commonExtensions) {
                        const fileName = `${pattern}.${ext}`;
                        const testPath = `${folder}/${fileName}`;
                        
                        if (!detectedImages.includes(fileName) && await imageExists(testPath)) {
                            detectedImages.push(fileName);
                            console.log(`üÜï Found new image: ${fileName} in ${folder}`);
                        }
                    }
                }
                
                // Sort images intelligently
                detectedImages.sort((a, b) => {
                    const aNum = parseInt(a.match(/bg?(\d+)/)?.[1] || a.match(/^\d+/)?.[0]);
                    const bNum = parseInt(b.match(/bg?(\d+)/)?.[1] || b.match(/^\d+/)?.[0]);
                    
                    if (aNum && bNum) return aNum - bNum;
                    if (aNum && !bNum) return -1;
                    if (!aNum && bNum) return 1;
                    return a.localeCompare(b);
                });
                
                newAvailableImages[folder] = detectedImages;
                totalFound += detectedImages.length;
                console.log(`üìÅ ${folder}: ${detectedImages.length} images (${detectedImages.length - baseImagesInFolder.length} new)`);
            }
            
            availableImages = newAvailableImages;
            console.log(`‚úÖ Smart scan complete: ${totalFound} total images found`);
            showToast(`üß† Smart scan: ${totalFound} ·∫£nh (bao g·ªìm c·∫£ ·∫£nh m·ªõi)`);
        }

        // Auto-refresh system
        let globalRefreshInterval = null;
        
        // Start global auto-refresh (runs even when gallery is closed)
        function startGlobalAutoRefresh() {
            if (globalRefreshInterval) return;
            
            // Auto-refresh every 10 seconds globally
            globalRefreshInterval = setInterval(async () => {
                try {
                    await enhancedRefreshImagesList();
                } catch (error) {
                    console.error('Auto-refresh error:', error);
                }
            }, 10000);
            
            console.log('üîÑ Global auto-refresh started (10s interval)');
        }
        
        // Stop global auto-refresh
        function stopGlobalAutoRefresh() {
            if (globalRefreshInterval) {
                clearInterval(globalRefreshInterval);
                globalRefreshInterval = null;
                console.log('‚èπÔ∏è Global auto-refresh stopped');
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', init);

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Add Q key navigation to go back to page3.html
            if (e.key.toLowerCase() === 'q') {
                window.location.href = 'page3.html';
            }
            if (e.key === 'Escape') {
                if (document.getElementById('editModal').style.display === 'flex') {
                    closeEditModal();
                }
                if (document.getElementById('imageGalleryModal').style.display === 'flex') {
                    closeImageGallery();
                }
            }
        });        // Copy all files content to clipboard
        async function copyAllToClipboard() {
            try {
                const vong1DataToSave = reconstructVong1Data();
                const vong2DataToSave = reconstructVong2Data();
                const vong3DataToSave = reconstructVong3Data();                const allData = {
                    'vong1.json': formatJSONWithPrettier(vong1DataToSave),
                    'vong2.json': formatJSONWithPrettier(vong2DataToSave),
                    'vong3.json': formatJSONWithPrettier(vong3DataToSave)
                };
                
                const combinedText = Object.entries(allData)
                    .map(([filename, content]) => `// ========== ${filename} ==========\n${content}`)
                    .join('\n\n');
                
                await navigator.clipboard.writeText(combinedText);
                showToast('ƒê√£ copy t·∫•t c·∫£ n·ªôi dung JSON v√†o clipboard. B·∫°n c√≥ th·ªÉ paste v√†o c√°c file t∆∞∆°ng ·ª©ng.');
            } catch (error) {
                console.error('Error copying to clipboard:', error);
                showToast('L·ªói khi copy v√†o clipboard: ' + error.message, 'error');
            }
        }

        // Track question changes
        function trackQuestionChange(questionId) {
            changedQuestions.add(questionId);
            updateSaveButtonState();
            console.log(`Question ${questionId} marked as changed. Total changes: ${changedQuestions.size}`);
        }

        // Update save button state
        function updateSaveButtonState() {
            const saveBtn = document.querySelector('.save-all-btn');
            if (saveBtn) {
                if (changedQuestions.size > 0) {
                    saveBtn.innerHTML = `<i class="fas fa-save mr-2"></i>Save All (${changedQuestions.size} thay ƒë·ªïi)`;
                    saveBtn.disabled = false;
                    saveBtn.classList.remove('opacity-50');
                } else {
                    saveBtn.innerHTML = '<i class="fas fa-save mr-2"></i>Save All';
                    saveBtn.disabled = true;
                    saveBtn.classList.add('opacity-50');
                }
            }
        }

        // Function to get changed files and their data
        function getChangedFilesData() {
            const changedFiles = {};
            
            // Check which rounds have changes
            const changedRounds = new Set();
            changedQuestions.forEach(questionId => {
                const question = allQuestions.find(q => q.id === questionId);
                if (question) {
                    changedRounds.add(question._round);
                }
            });
            
            console.log('Changed rounds:', Array.from(changedRounds));
            console.log('Changed questions:', Array.from(changedQuestions));
            
            // Only include files that have changes
            changedRounds.forEach(round => {
                if (round === 1 && originalData.vong1) {
                    changedFiles['vong1.json'] = updateOriginalData(originalData.vong1, 1);
                } else if (round === 2 && originalData.vong2) {
                    changedFiles['vong2.json'] = updateOriginalData(originalData.vong2, 2);
                } else if (round === 3 && originalData.vong3) {
                    changedFiles['vong3.json'] = updateOriginalData(originalData.vong3, 3);
                }
            });
            
            return changedFiles;
        }

        // Function to update original data structure with changes
        function updateOriginalData(originalData, round) {
            const updatedData = JSON.parse(JSON.stringify(originalData)); // Deep clone
            
            // Update only changed questions in their original positions
            function updateNestedStructure(obj, path = []) {
                for (const key in obj) {
                    if (Array.isArray(obj[key])) {
                        // This is an array of questions
                        obj[key].forEach((item, index) => {
                            if (item && item.id && changedQuestions.has(item.id)) {
                                const updatedQuestion = allQuestions.find(q => q.id === item.id);
                                if (updatedQuestion) {
                                    // Only update the image-related fields we allow editing
                                    const fieldsToUpdate = ['image_id', 'use_image', 'position_image', 'question_image', 'bg_image', 'bg_image_overlay'];
                                    fieldsToUpdate.forEach(field => {
                                        if (updatedQuestion.hasOwnProperty(field)) {
                                            obj[key][index][field] = updatedQuestion[field];
                                        }
                                    });
                                }
                            }
                        });
                    } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                        updateNestedStructure(obj[key], [...path, key]);
                    }
                }
            }
            
            updateNestedStructure(updatedData);
            return updatedData;
        }

        // Helper function to save file with File System Access API
        async function saveFileWithAPI(filename, data) {
            try {
                const fileHandle = await window.showSaveFilePicker({
                    suggestedName: filename,
                    types: [{
                        description: 'JSON files',
                        accept: { 'application/json': ['.json'] }

                    }]                });                  const writable = await fileHandle.createWritable();
                const formattedContent = formatJSONWithPrettier(data);
                await writable.write(formattedContent);
                await writable.close();
                
            } catch (error) {
                if (error.name !== 'AbortError') {
                    throw error;
                }
            }
        }

        // Auto-refresh gallery when folder changes
        let galleryRefreshInterval = null;
        
        // Function to refresh images list by testing file existence
        async function refreshImagesList() {
            console.log('Refreshing images list...');
            const commonExtensions = ['jpg', 'jpeg', 'png', 'svg', 'webp'];
            const folders = ['images', 'images/bg', 'images/cauhoi', 'images/illustrative', 'images/index_images'];
            
            const newAvailableImages = {};
            
            for (const folder of folders) {
                const detectedImages = [];
                
                // Test common filenames with different extensions
                const testNames = [
                    // Common background names
                    'bg', 'bg1', 'bg2', 'bg3', 'bg4', 'bg5', 'bg6', 'bg7', 'bg8', 'bg9', 'bg10',
                    'bg11', 'bg12', 'bg2.1', 'background', 'wallpaper',
                    // Common question images
                    'v1_image1', 'v2_image1', 'v3_yte', 'v3_yte2', 'image1', 'image2', 'image3',
                    'V2_BV_HA_4', 'V2_BV_HA_9', 'V2_BXV_HA_15', 'V2_BXV_HA_22',
                    'V2_KTM_HA_10', 'V2_KTM_HA_4', 'ktm_image_4',
                    'v3_c1', 'v3_c2', 'v3_c3', 'v3_c4', 'v3_c5', 'v3_c6', 'v3_c7', 'v3_c8', 'v3_c9', 'v3_c10',
                    // Common illustrative images
                    'illustrative_cspl_tn_1', 'illustrative_cspl_tn_2', 'illustrative_cspl_tn_3',
                    'illustrative_cspl_tn_5', 'illustrative_yt_sc_tn_3', 'illustrative_yt_th_1',
                    'icon1', 'icon2', 'logo', 'warning', 'check', 'arrow', 'safety1', 'safety2',
                    // SVG files
                    'svg (1)', 'svg (2)', 'svg (3)', 'svg',
                    // Index images
                    '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'
                ];
                
                for (const name of testNames) {
                    for (const ext of commonExtensions) {
                        const testPath = `${folder}/${name}.${ext}`;
                        if (await imageExists(testPath)) {
                            detectedImages.push(`${name}.${ext}`);
                        }
                    }
                }
                
                // Also test for any numbered files up to 50
                for (let i = 1; i <= 50; i++) {
                    for (const ext of commonExtensions) {
                        const testPath = `${folder}/${i}.${ext}`;
                        if (await imageExists(testPath)) {
                            detectedImages.push(`${i}.${ext}`);
                        }
                    }
                }
                
                newAvailableImages[folder] = [...new Set(detectedImages)].sort();
            }
            
            // Keep uploaded images
            if (availableImages['images/image_upload']) {
                newAvailableImages['images/image_upload'] = availableImages['images/image_upload'];
            } else {
                newAvailableImages['images/image_upload'] = [];
            }
            
            // Update available images
            const oldCount = Object.values(availableImages).flat().length;
            availableImages = newAvailableImages;
            const newCount = Object.values(availableImages).flat().length;
            
            if (newCount !== oldCount) {
                console.log(`Images updated: ${oldCount} ‚Üí ${newCount}`);
                
                // If gallery is open, refresh it
                if (document.getElementById('imageGalleryModal').style.display === 'flex') {
                    populateFolderTree();
                    // Refresh current folder view if any folder is active
                    const activeFolder = document.querySelector('.folder-item.active');
                    if (activeFolder) {
                        const folderPath = activeFolder.dataset.folder;
                        if (folderPath) {
                            showImagesInFolder(folderPath);
                        }
                    }
                }
                
                return true; // Images changed
            }
            
            return false; // No changes
        }
        
        // Start auto-refresh when gallery opens
        function startGalleryAutoRefresh() {
            if (galleryRefreshInterval) {
                clearInterval(galleryRefreshInterval);
            }
            
            // Refresh every 3 seconds when gallery is open
            galleryRefreshInterval = setInterval(async () => {
                if (document.getElementById('imageGalleryModal').style.display === 'flex') {
                    await refreshImagesList();
                } else {
                    // Stop refresh when gallery is closed
                    clearInterval(galleryRefreshInterval);
                    galleryRefreshInterval = null;
                }
            }, 3000);
        }
        
        // Manual refresh button
        function manualRefreshGallery() {
            showToast('ƒêang qu√©t l·∫°i th∆∞ m·ª•c...', 'info');
            refreshImagesList().then(changed => {
                if (changed) {
                    showToast('ƒê√£ c·∫≠p nh·∫≠t danh s√°ch ·∫£nh');
                } else {
                    showToast('Kh√¥ng c√≥ ·∫£nh m·ªõi');
                }
            });
        }

        // ...existing code...
    </script>
</body>
</html>
